export class MaskBlockList {
  constructor(_list = []) {
    this._list = _list;
  }
  get lastPosition() {
    return this._list[this._list.length - 1].to;
  }
  get list() {
    return this._list;
  }
  set list(list) {
    this._list = list;
  }
  clone() {
    return new MaskBlockList([...this._list]);
  }
  findByIndex(index, blocks = this.list) {
    return blocks.find(block => block.from <= index && index < block.to);
  }
  getPlaceholderMask() {
    const placeholder = [];
    this.list.forEach(block => {
      const length = block.to - block.from;
      for (let index = 0; index < length; index++) {
        placeholder.push(block.mask);
      }
    });
    return placeholder.join('');
  }
  getRawValueWithoutMaskByContext(context) {
    return this.getRawValueWithoutMask(context.value);
  }
  getRawValueWithoutMask(value) {
    if (value) {
      let rawValue = [];
      const chars = value.split('');
      for (let index = 0; index < chars.length; index++) {
        const char = chars[index];
        const block = this.findByIndex(index);
        if (block && !block.isSeparator) {
          rawValue.push(char.replace(block.mask, ''));
        }
        else {
          rawValue.push(char);
        }
      }
      rawValue = rawValue.filter(v => v);
      const amountSeparators = this.list.filter(block => block.isSeparator).length;
      if (amountSeparators === rawValue.length) {
        return '';
      }
      return rawValue.join('');
    }
    return '';
  }
  formatBlocks(value, activeBlockIndex) {
    let newValue = `${value}`;
    for (let index = 0; index < this.list.length; index++) {
      const block = this.list[index];
      if (activeBlockIndex !== index && !block.isSeparator && block.isTouched(newValue)) {
        const blockValue = block.getValueOfTheBlock(newValue);
        const newBlockValue = block.format(blockValue);
        newValue = newValue.substring(0, block.from) + newBlockValue + newValue.substring(block.to);
      }
    }
    return newValue;
  }
  getBlockIndexFromPosition(position) {
    const length = this.list.reduce((acc, block) => acc + block.to - block.from, 0);
    if (position === length) {
      return this.list.length - 1;
    }
    const index = this.list.findIndex(block => block.from <= position && position < block.to);
    return index < 0 ? undefined : Math.min(length, index);
  }
  verifyCallOfNextSeparator(key, index) {
    if (this.list.length - 1 > index) {
      const nextBlock = this.list[index + 1];
      if (nextBlock.isSeparator && nextBlock.mask === key) {
        return true;
      }
    }
    return false;
  }
}
