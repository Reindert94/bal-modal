var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { h, Host, } from '@stencil/core';
import { generateCalendarGrid, generateMonths, generateWeekDays, generateYears, getFirstWeekdayOfMonth, } from '../utils/calendar';
import { BalDate } from '../../../../utils/date';
import { Logger } from '../../../../utils/log';
import { ListenToConfig, defaultConfig } from '../../../../utils/config';
import { waitAfterFramePaint } from '../../../../utils/helpers';
import { BEM } from '../../../../utils/bem';
import { CalendarList } from './components/bal-date-calendar__list';
import { CalendarGrid } from './components/bal-date-calendar__gird';
import { ListenToSwipe } from '../../../../utils/swipe';
import { CalendarNav } from './components/bal-date-calendar__nav';
export class DateCalendar {
  constructor() {
    this.onSelectDay = (isoDate) => {
      this.valueChanged(isoDate, this.selectedDate);
      this.balChange.emit(this.selectedDate);
    };
    this.onClickNextMonth = () => {
      let nextYear = this.year;
      let nextMonth = this.month + 1;
      if (nextMonth > 12) {
        nextMonth = 1;
        nextYear = nextYear + 1;
      }
      this.generateGridByMonthAndYear(nextMonth, nextYear);
    };
    this.onClickPreviousMonth = () => {
      let nextYear = this.year;
      let nextMonth = this.month - 1;
      if (nextMonth < 1) {
        nextMonth = 12;
        nextYear = nextYear - 1;
      }
      this.generateGridByMonthAndYear(nextMonth, nextYear);
    };
    this.onClickSelectMonthAndYear = async () => {
      if (this.isCalendarVisible === true) {
        this.isCalendarVisible = false;
        this.isYearListVisible = true;
        this.isMonthListVisible = false;
        await waitAfterFramePaint();
        if (this.yearListEl) {
          const selectedYearEl = this.yearListEl.querySelector(`#year-${this.year}`);
          if (selectedYearEl) {
            const rowHeight = 26 + 8 + 4;
            this.yearListEl.scrollTop = selectedYearEl.offsetTop - rowHeight * 2;
          }
          else {
            this.yearListEl.scrollTop = 0;
          }
        }
      }
      else {
        this.isCalendarVisible = true;
        this.isYearListVisible = false;
        this.isMonthListVisible = false;
      }
    };
    this.onClickYear = (newYear) => {
      this.isYearListVisible = false;
      this.isMonthListVisible = true;
      this.generateGridByMonthAndYear(this.month, newYear);
    };
    this.onClickMonth = (newMonth) => {
      this.isYearListVisible = false;
      this.isMonthListVisible = false;
      this.isCalendarVisible = true;
      this.generateGridByMonthAndYear(newMonth, this.year);
    };
    this.selectedDate = '';
    this.monthFullNames = [];
    this.weekdays = [];
    this.months = [];
    this.years = [];
    this.calendarGrid = [];
    this.firstDayOfWeek = 0;
    this.month = 0;
    this.year = 0;
    this.language = defaultConfig.language;
    this.isCalendarVisible = true;
    this.isYearListVisible = false;
    this.isMonthListVisible = false;
    this.value = undefined;
    this.defaultDate = undefined;
    this.allowedDates = undefined;
    this.min = undefined;
    this.max = undefined;
    this.minYearProp = undefined;
    this.maxYearProp = undefined;
  }
  createLogger(log) {
    this.log = log;
  }
  valueChanged(newValue, oldValue) {
    if (newValue !== oldValue) {
      const date = BalDate.fromISO(newValue);
      if (!date.isValid) {
        this.generateGridByDefaultDate();
        this.selectedDate = '';
      }
      else {
        this.generateGridByDate(date);
        this.selectedDate = date.toISODate();
      }
    }
  }
  rangePropChanged() {
    this.months = generateMonths(this.language, this.year, this.min, this.max);
    this.years = generateYears(this.minYear, this.maxYear);
  }
  yearRangePropChanged() {
    this.years = generateYears(this.minYear, this.maxYear);
  }
  connectedCallback() {
    this.generateGridByDefaultDate();
    this.valueChanged(this.value, undefined);
  }
  async configChanged(state) {
    this.years = generateYears(this.minYear, this.maxYear);
    this.months = generateMonths(state.language, this.year, this.min, this.max);
    this.weekdays = generateWeekDays(state.language);
    this.monthFullNames = BalDate.infoMonths({ format: 'long', locale: this.language });
    this.language = state.language;
  }
  swipeListener({ left, right }) {
    if (left) {
      this.onClickNextMonth();
    }
    else if (right) {
      this.onClickPreviousMonth();
    }
  }
  get minYear() {
    if (this.minYearProp === undefined) {
      const today = new Date();
      const year = today.getFullYear();
      const defaultMinYear = year - 100;
      if (this.min) {
        const date = BalDate.fromISO(this.min);
        return date.year || defaultMinYear;
      }
      else {
        return defaultMinYear;
      }
    }
    return this.minYearProp;
  }
  get maxYear() {
    if (this.maxYearProp === undefined) {
      const today = new Date();
      const year = today.getFullYear();
      const defaultMaxYear = year + 50;
      if (this.max) {
        const date = BalDate.fromISO(this.max);
        return date.year || defaultMaxYear;
      }
      else {
        return defaultMaxYear;
      }
    }
    return this.maxYearProp;
  }
  generateGridByDate(date) {
    if (date.year !== undefined && date.month !== undefined) {
      this.generateGridByMonthAndYear(date.month, date.year);
    }
  }
  generateGridByDefaultDate() {
    const date = BalDate.fromISO(this.defaultDate);
    if (date.isValid) {
      this.generateGridByDate(date);
    }
    else {
      const today = new Date();
      this.month = today.getMonth() + 1;
      this.year = today.getFullYear();
      this.calendarGrid = generateCalendarGrid(this.year, this.month, this.min, this.max, this.allowedDates);
      this.firstDayOfWeek = getFirstWeekdayOfMonth(this.year, this.month);
    }
  }
  generateGridByMonthAndYear(month, year) {
    if (this.month !== month || this.year !== year) {
      this.calendarGrid = generateCalendarGrid(year, month, this.min, this.max, this.allowedDates);
      this.firstDayOfWeek = getFirstWeekdayOfMonth(year, month);
    }
    this.month = month;
    this.year = year;
  }
  render() {
    var _a;
    const today = new Date();
    const todayYear = today.getFullYear();
    const todayMonth = today.getMonth() + 1;
    const girdHeight = ((_a = this.gridEl) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0;
    const block = BEM.block('date-calendar');
    const blockBody = block.element('body');
    const blockFoot = block.element('foot');
    return (h(Host, { class: Object.assign({}, block.class()) }, h(CalendarNav, { language: this.language, monthFullNames: this.monthFullNames, month: this.month, year: this.year, isCalendarVisible: this.isCalendarVisible, isListVisible: this.isMonthListVisible || this.isYearListVisible, onClickSelectMonthAndYear: this.onClickSelectMonthAndYear, onClickPreviousMonth: this.onClickPreviousMonth, onClickNextMonth: this.onClickNextMonth }), h("div", { class: Object.assign({}, blockBody.class()) }, h(CalendarGrid, { isVisible: this.isCalendarVisible, grid: this.calendarGrid, weekdays: this.weekdays, firstDayOfWeek: this.firstDayOfWeek, selectedDate: this.selectedDate, ref: el => (this.gridEl = el), onSelectDay: isoDate => this.onSelectDay(isoDate) }), h(CalendarList, { name: "year", isVisible: this.isYearListVisible, girdHeight: girdHeight, todayValue: todayYear, selectedValue: this.year, list: this.years, ref: el => (this.yearListEl = el), onSelect: item => this.onClickYear(item.value) }), h(CalendarList, { name: "month", isVisible: this.isMonthListVisible, girdHeight: girdHeight, todayValue: todayMonth, selectedValue: this.month, list: this.months, onSelect: item => this.onClickMonth(item.value) })), h("div", { class: Object.assign({}, blockFoot.class()) }, h("slot", null))));
  }
  static get is() { return "bal-date-calendar"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() {
    return {
      "$": ["bal-date-calendar.sass"]
    };
  }
  static get styleUrls() {
    return {
      "$": ["bal-date-calendar.css"]
    };
  }
  static get properties() {
    return {
      "value": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "The value of selected date, which accepts ISO 8601 date strings (YYYY-MM-DD)."
        },
        "attribute": "value",
        "reflect": false
      },
      "defaultDate": {
        "type": "string",
        "mutable": false,
        "complexType": {
          "original": "string",
          "resolved": "string | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "The date to defines where the calendar starts. The prop accepts ISO 8601 date strings (YYYY-MM-DD). Default is today."
        },
        "attribute": "default-date",
        "reflect": false
      },
      "allowedDates": {
        "type": "unknown",
        "mutable": false,
        "complexType": {
          "original": "BalProps.BalDateCalendarAllowedDatesCallback | undefined",
          "resolved": "((isoDate: string) => boolean) | undefined",
          "references": {
            "BalProps": {
              "location": "global"
            }
          }
        },
        "required": false,
        "optional": false,
        "docs": {
          "tags": [],
          "text": "Callback to determine which date in the datepicker should be selectable."
        },
        "defaultValue": "undefined"
      },
      "min": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "The minimum datetime allowed. Value must be a date string\nfollowing the\n[ISO 8601 datetime format standard](https://www.w3.org/TR/NOTE-datetime),\nsuch as `1996-12-19`. The format does not have to be specific to an exact\ndatetime. For example, the minimum could just be the year, such as `1994`.\nDefaults to the beginning of the year, 100 years ago from today."
        },
        "attribute": "min",
        "reflect": false
      },
      "max": {
        "type": "string",
        "mutable": true,
        "complexType": {
          "original": "string",
          "resolved": "string | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "The maximum datetime allowed. Value must be a date string\nfollowing the\n[ISO 8601 datetime format standard](https://www.w3.org/TR/NOTE-datetime),\n`1996-12-19`. The format does not have to be specific to an exact\ndatetime. For example, the maximum could just be the year, such as `1994`.\nDefaults to the end of this year."
        },
        "attribute": "max",
        "reflect": false
      },
      "minYearProp": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "Earliest year available for selection"
        },
        "attribute": "min-year",
        "reflect": false
      },
      "maxYearProp": {
        "type": "number",
        "mutable": false,
        "complexType": {
          "original": "number",
          "resolved": "number | undefined",
          "references": {}
        },
        "required": false,
        "optional": true,
        "docs": {
          "tags": [],
          "text": "Latest year available for selection"
        },
        "attribute": "max-year",
        "reflect": false
      }
    };
  }
  static get states() {
    return {
      "selectedDate": {},
      "monthFullNames": {},
      "weekdays": {},
      "months": {},
      "years": {},
      "calendarGrid": {},
      "firstDayOfWeek": {},
      "month": {},
      "year": {},
      "language": {},
      "isCalendarVisible": {},
      "isYearListVisible": {},
      "isMonthListVisible": {}
    };
  }
  static get events() {
    return [{
        "method": "balChange",
        "name": "balChange",
        "bubbles": true,
        "cancelable": true,
        "composed": true,
        "docs": {
          "tags": [],
          "text": "Emitted when a option got selected."
        },
        "complexType": {
          "original": "BalEvents.BalDateCalendarChangeDetail",
          "resolved": "string | undefined",
          "references": {
            "BalEvents": {
              "location": "global"
            }
          }
        }
      }];
  }
  static get methods() {
    return {
      "configChanged": {
        "complexType": {
          "signature": "(state: BalConfigState) => Promise<void>",
          "parameters": [{
              "tags": [],
              "text": ""
            }],
          "references": {
            "Promise": {
              "location": "global"
            },
            "BalConfigState": {
              "location": "import",
              "path": "../../../../utils/config"
            }
          },
          "return": "Promise<void>"
        },
        "docs": {
          "text": "",
          "tags": [{
              "name": "internal",
              "text": "define config for the component"
            }]
        }
      }
    };
  }
  static get elementRef() { return "el"; }
  static get watchers() {
    return [{
        "propName": "value",
        "methodName": "valueChanged"
      }, {
        "propName": "min",
        "methodName": "rangePropChanged"
      }, {
        "propName": "max",
        "methodName": "rangePropChanged"
      }, {
        "propName": "minYearProp",
        "methodName": "yearRangePropChanged"
      }, {
        "propName": "maxYearProp",
        "methodName": "yearRangePropChanged"
      }];
  }
}
__decorate([
  Logger('bal-date-calendar')
], DateCalendar.prototype, "createLogger", null);
__decorate([
  ListenToConfig()
], DateCalendar.prototype, "configChanged", null);
__decorate([
  ListenToSwipe({ mobileOnly: true })
], DateCalendar.prototype, "swipeListener", null);
