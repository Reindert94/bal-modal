'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index = require('./index-b37b271f.js');
const log = require('./log-911f84ec.js');
const bem = require('./bem-5d122a5c.js');
const browser = require('./browser-791d6902.js');
const device = require('./device-76e9eca9.js');
const floatingUi_dom_esm = require('./floating-ui.dom.esm-02693def.js');

const showContainerElement = (containerEl) => {
  if (containerEl) {
    showElement(containerEl);
  }
};
const hideContainerElement = (containerEl) => {
  if (containerEl) {
    hideElement(containerEl);
  }
};
const showArrowElement = (arrowEl) => {
  if (arrowEl) {
    showElement(arrowEl);
  }
};
const hideArrowElement = (arrowEl) => {
  if (arrowEl) {
    Object.assign(arrowEl.style, {
      left: '',
      top: '',
      display: 'none',
      visibility: 'hidden',
    });
  }
};
const showElement = (element) => {
  if (element) {
    element.style.setProperty('display', 'block');
    element.style.setProperty('visibility', 'visible');
  }
};
const hideElement = (element) => {
  if (element) {
    element.style.removeProperty('display');
    element.style.removeProperty('visibility');
  }
};

const balTooltipCss = ":host{--bal-tooltip-container-background:var(--bal-color-primary-6);--bal-tooltip-max-width:auto;--bal-tooltip-radius:var(--bal-radius-normal);--bal-tooltip-shadow:var(--bal-shadow-large);--bal-tooltip-arrow-background:var(--bal-color-primary-6);--bal-tooltip-font-family:var(--bal-font-family-text);--bal-tooltip-font-size:var(--bal-size-small)}:host{position:static;display:inline;z-index:var(--bal-z-index-tooltip)}.bal-tooltip__container{background-color:var(--bal-tooltip-container-background);display:none;visibility:hidden;color:#fff;padding:var(--bal-space-x-small);border-radius:var(--bal-tooltip-radius);-webkit-box-shadow:var(--bal-tooltip-shadow);box-shadow:var(--bal-tooltip-shadow);width:var(--bal-tooltip-max-width);position:absolute;top:0;left:0}.bal-tooltip__inner{overflow-y:auto;max-height:calc(var(--bal-app-height, 100%) - 8rem)}.bal-tooltip__inner__content{width:100%;font-family:var(--bal-tooltip-font-family);font-size:var(--bal-tooltip-font-size)}.bal-tooltip__arrow{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:absolute;width:.5rem;height:.5rem;background:var(--bal-tooltip-arrow-background);-webkit-transform:rotate(45deg);transform:rotate(45deg);display:none;visibility:hidden}.bal-tooltip-variant-popover-trigger,.bal-tooltip-permanent-trigger{z-index:calc(var(--bal-z-index-tooltip) + 1) !important;position:relative !important}";

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const Tooltip = class {
  constructor(hostRef) {
    index.registerInstance(this, hostRef);
    this.balWillAnimate = index.createEvent(this, "balWillAnimate", 7);
    this.balDidAnimate = index.createEvent(this, "balDidAnimate", 7);
    this.tooltipId = `bal-to-${tooltipIds++}`;
    this.reference = '';
    this.placement = 'bottom';
    this.offset = 0;
    this.presented = false;
    this.contentWidth = undefined;
  }
  createLogger(log) {
    this.log = log;
  }
  contentWidthChanged(newValue, oldValue) {
    if (newValue !== oldValue) {
      if (newValue === undefined) {
        this.el.style.removeProperty('--bal-tooltip-max-width');
      }
      else {
        this.el.style.setProperty('--bal-tooltip-max-width', `${this.contentWidth}px`);
      }
    }
  }
  componentDidLoad() {
    this.contentWidthChanged(this.contentWidth, 0);
    if (!device.balDevice.hasTouchScreen) {
      let showEvents = [];
      let hideEvents = [];
      showEvents = ['mouseenter', 'focus'];
      hideEvents = ['mouseleave', 'blur'];
      showEvents.forEach(event => {
        if (this.triggerElement) {
          this.triggerElement.addEventListener(event, () => this.present());
        }
      });
      hideEvents.forEach(event => {
        if (this.triggerElement) {
          this.triggerElement.addEventListener(event, () => this.dismiss());
        }
      });
    }
  }
  async present() {
    if (!this.trigger && browser.balBrowser.hasDocument) {
      const firstTrigger = Array.from(document.querySelectorAll(`[id="${this.reference}"]`))[0];
      this.trigger = firstTrigger;
    }
    if (this.trigger && this.containerEl && this.arrowEl) {
      this.balWillAnimate.emit();
      const triggerVariantAttr = this.trigger.attributes.getNamedItem('bal-tooltip-placement');
      if (triggerVariantAttr) {
        this.placement = triggerVariantAttr.value;
      }
      else {
        this.placement = this.placement;
      }
      showContainerElement(this.containerEl);
      showArrowElement(this.arrowEl);
      this.trigger.classList.add('bal-tooltip-trigger');
      this.presented = true;
      this.cleanup = floatingUi_dom_esm.autoUpdate(this.trigger, this.containerEl, () => {
        this.update();
      });
      this.balDidAnimate.emit();
      return true;
    }
    return false;
  }
  async dismiss() {
    if (this.containerEl && this.arrowEl && this.trigger) {
      this.balWillAnimate.emit();
      if (this.cleanup) {
        this.cleanup();
      }
      this.trigger.classList.remove('bal-tooltip-trigger');
      hideContainerElement(this.containerEl);
      hideArrowElement(this.arrowEl);
      this.presented = false;
      this.balDidAnimate.emit();
      return true;
    }
    return false;
  }
  async update() {
    if (this.trigger && this.containerEl && this.arrowEl) {
      this.balWillAnimate.emit();
      floatingUi_dom_esm.computePosition(this.trigger, this.containerEl, {
        placement: this.placement,
        middleware: [
          floatingUi_dom_esm.shift(),
          floatingUi_dom_esm.flip(),
          floatingUi_dom_esm.offset(8),
          floatingUi_dom_esm.arrow({
            element: this.arrowEl,
            padding: 4,
          }),
        ],
      }).then(({ x, y, middlewareData, placement }) => {
        const side = placement.split('-')[0];
        const staticSide = {
          top: 'bottom',
          right: 'left',
          bottom: 'top',
          left: 'right',
        }[side];
        if (this.containerEl) {
          Object.assign(this.containerEl.style, {
            left: `${x}px`,
            top: `${y}px`,
          });
        }
        if (middlewareData.arrow && this.arrowEl) {
          const arrowPosition = middlewareData.arrow;
          Object.assign(this.arrowEl.style, {
            left: x != null && arrowPosition.x != null ? `${arrowPosition.x}px` : '',
            top: y != null && arrowPosition.y != null ? `${arrowPosition.y}px` : '',
            right: '',
            bottom: '',
            [staticSide]: `${-4}px`,
          });
        }
      });
      this.balDidAnimate.emit();
      return true;
    }
    return false;
  }
  get triggerElement() {
    return document.querySelector(`[id="${this.reference}"]`);
  }
  render() {
    const block = bem.BEM.block('tooltip');
    const containerBlock = block.element('container');
    const arrowBlock = block.element('arrow');
    const innerBlock = block.element('inner');
    const innerContentBlock = innerBlock.element('content');
    return (index.h(index.Host, { class: Object.assign({}, block.class()), role: "dialog", "aria-hidden": `${this.presented !== true}`, "aria-modal": `${this.presented === true}`, "aria-presented": `${this.presented === true}` }, index.h("div", { class: Object.assign({}, containerBlock.class()), ref: containerEl => (this.containerEl = containerEl) }, index.h("div", { class: Object.assign({}, arrowBlock.class()), ref: arrowEl => (this.arrowEl = arrowEl) }), index.h("bal-stack", { layout: "vertical", class: Object.assign({}, innerBlock.class()) }, index.h("div", { class: Object.assign({}, innerContentBlock.class()), ref: contentEl => (this.contentEl = contentEl), "data-test": "bal-tooltip-content" }, index.h("slot", null))))));
  }
  get el() { return index.getElement(this); }
  static get watchers() { return {
    "contentWidth": ["contentWidthChanged"]
  }; }
};
__decorate([
  log.Logger('bal-tooltip')
], Tooltip.prototype, "createLogger", null);
let tooltipIds = 0;
Tooltip.style = {
  css: balTooltipCss
};

exports.bal_tooltip = Tooltip;
