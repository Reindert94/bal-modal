'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const index$1 = require('./index-b37b271f.js');
const index_esm = require('./index.esm-1d62ac7e.js');
const index = require('./index-e6a233be.js');
const date = require('./date-63f49320.js');
const log = require('./log-911f84ec.js');
const initialize = require('./initialize-e84e0c8f.js');
const config_decorator = require('./config.decorator-f5fee2ba.js');
const helpers = require('./helpers-c580b28f.js');
const bem = require('./bem-5d122a5c.js');
const swipe_decorator = require('./swipe.decorator-f8f83d1d.js');
const attributes = require('./attributes-fa738cf7.js');
const keys_constant = require('./keys.constant-6ed40b9d.js');
const index$2 = require('./index-c4d0b927.js');
const formInput = require('./form-input-4fee10e1.js');
const form = require('./form-9af6cd7d.js');
require('./_commonjsHelpers-bcc1208a.js');
require('./index-843a2913.js');
require('./browser-791d6902.js');
require('./icons.constant-2abdbd0f.js');
require('./swipe.subject-f091378e.js');
require('./device-76e9eca9.js');
require('./listener-4161102f.js');

function getDaysInMonth(year, month) {
  if (month < 1 || year < 0) {
    return undefined;
  }
  return new Date(year, month, 0).getDate();
}
function isoDateOfDay(day, month, year) {
  return `${year}-${index_esm.lodash_padstart(`${month}`, 2, '0')}-${index_esm.lodash_padstart(`${day}`, 2, '0')}`;
}
function isoDateOfToday() {
  const today = new Date();
  return `${today.getFullYear()}-${index_esm.lodash_padstart(`${today.getMonth() + 1}`, 2, '0')}-${index_esm.lodash_padstart(`${today.getDate()}`, 2, '0')}`;
}
function generateCalendarGrid(year, month, min, max, allowedDates) {
  const grid = [];
  const numDays = getDaysInMonth(year, month);
  const firstDay = getFirstDayOfMonth(year, month);
  if (numDays !== undefined && firstDay) {
    const isoToday = isoDateOfToday();
    const dateMin = date.BalDate.fromISO(min);
    const dateMax = date.BalDate.fromISO(max);
    const allowedDate = (isoDate) => {
      if (index.lodash_isnil(allowedDates)) {
        return false;
      }
      return !allowedDates(isoDate);
    };
    for (let day = 1; day <= numDays; day++) {
      const isoDate = isoDateOfDay(day, month, year);
      grid.push({
        day,
        month,
        year,
        isoDate,
        fullDate: date.BalDate.fromISO(isoDate).toFormat(),
        today: isoToday === isoDate,
        disabled: dateMin.isAfter(isoDate) || dateMax.isBefore(isoDate) || allowedDate(isoDate),
      });
    }
  }
  return grid;
}
function getFirstWeekdayOfMonth(year, month) {
  if (month < 1 || year < 0) {
    return 1;
  }
  const date = new Date(year, month - 1, 1);
  const weekday = date.getDay();
  return weekday === 0 ? 7 : weekday;
}
function validateLanguage(language) {
  if (['en', 'de', 'fr', 'it', 'nl', 'es', 'pl', 'pt', 'sv', 'fi'].includes(language)) {
    return language;
  }
  return 'de';
}
function generateYears(minYear, maxYear) {
  const list = [];
  for (let year = minYear; year <= maxYear; year++) {
    list.push({
      value: year,
      label: `${year}`,
      disabled: false,
    });
  }
  return list;
}
function generateMonths(language, currentYear, min, max) {
  const locale = validateLanguage(language);
  const months = date.BalDate.infoMonths({ format: 'long', locale });
  let minMonth = 0;
  if (min && currentYear !== undefined) {
    const minDate = date.BalDate.fromISO(min);
    if (minDate.isValid) {
      if (currentYear > minDate.year) {
        minMonth = 12;
      }
      else {
        minMonth = minDate.month || minMonth;
      }
    }
  }
  let maxMonth = 12;
  if (max && currentYear !== undefined) {
    const maxDate = date.BalDate.fromISO(max);
    if (maxDate.isValid) {
      if (currentYear < maxDate.year) {
        maxMonth = 0;
      }
      else {
        maxMonth = maxDate.month || maxMonth;
      }
    }
  }
  return months.map((label, index) => ({
    label,
    value: index + 1,
    disabled: index < minMonth - 1 || index > maxMonth - 1,
  }));
}
function generateWeekDays(language) {
  const locale = validateLanguage(language);
  const weekdaysMin = date.BalDate.infoWeekdays({ format: 'short', locale });
  const weekdays = date.BalDate.infoWeekdays({ format: 'long', locale });
  return weekdaysMin.map((weekdayMin, index) => ({
    ariaLabel: weekdays[index],
    textContent: weekdayMin,
  }));
}
function getFirstDayOfMonth(year, month) {
  if (month < 1 || month > 12 || year < 0) {
    return undefined;
  }
  return new Date(year, month - 1, 1);
}

const CalendarList = ({ name, isVisible, girdHeight, list, todayValue, selectedValue, onSelect, ref, }) => {
  const block = bem.BEM.block('date-calendar');
  const blockBody = block.element('body');
  const blockBodyList = blockBody.element('list');
  return (index$1.h("ul", { class: Object.assign(Object.assign(Object.assign({}, blockBodyList.class()), blockBodyList.modifier(name).class()), blockBodyList.modifier('visible').class(isVisible)), "aria-hidden": isVisible ? 'false' : 'true', style: {
      height: `${girdHeight - 2 - 8 - 8}px`,
    }, ref: el => (ref ? ref(el) : undefined) }, list.map(item => (index$1.h("li", { id: `${name}-${item.value}` },
    index$1.h("button", { class: Object.assign(Object.assign(Object.assign(Object.assign({}, blockBodyList.element('item').class()), blockBodyList
        .element('item')
        .modifier('today')
        .class(item.value === todayValue)), blockBodyList
        .element('item')
        .modifier('selected')
        .class(item.value === selectedValue)), blockBodyList.element('item').modifier('disabled').class(item.disabled)), tabIndex: -1, onClick: () => onSelect(item) }, item.label))))));
};

const CalendarGrid = ({ isVisible, ref, grid, weekdays, selectedDate, firstDayOfWeek, onSelectDay, }) => {
  const block = bem.BEM.block('date-calendar');
  const blockBody = block.element('body');
  const blockBodyGrid = blockBody.element('grid');
  return (index$1.h("div", { role: "grid", class: Object.assign(Object.assign({}, blockBodyGrid.class()), blockBodyGrid.modifier('visible').class(isVisible)), "aria-hidden": isVisible ? 'false' : 'true', ref: el => ref(el) },
    index$1.h("div", { role: "row", class: Object.assign({}, blockBodyGrid.element('head').class()) }, weekdays.map(weekday => (index$1.h("span", { role: "columnheader", "aria-label": weekday.ariaLabel, title: weekday.ariaLabel }, weekday.textContent)))),
    index$1.h("div", { role: "row", class: Object.assign({}, blockBodyGrid.element('body').class()), style: { '--bal-date-first-week-day': `${firstDayOfWeek}` } }, grid.map(cell => (index$1.h("bal-date-calendar-cell", Object.assign({}, cell, { selected: cell.isoDate === selectedDate, onBalSelectDay: ({ detail }) => onSelectDay(detail) })))))));
};

const CalendarNav = ({ language, onClickSelectMonthAndYear, monthFullNames, month, year, isCalendarVisible, isListVisible, onClickPreviousMonth, onClickNextMonth, }) => {
  const block = bem.BEM.block('date-calendar');
  const blockNav = block.element('nav');
  const nextMonthLabel = date.i18nBalDate[language].nextMonth;
  const previousMonthLabel = date.i18nBalDate[language].previousMonth;
  const selectMonthLabel = date.i18nBalDate[language].selectMonth;
  return (index$1.h("div", { class: Object.assign({}, blockNav.class()) },
    index$1.h("div", { class: Object.assign({}, blockNav.modifier('start').class()) },
      index$1.h("button", { title: selectMonthLabel, "aria-label": selectMonthLabel, tabIndex: -1, "data-test": "change-year-month", onClick: onClickSelectMonthAndYear },
        index$1.h("span", null,
          monthFullNames[month - 1],
          " ",
          year),
        index$1.h("bal-icon", { name: "caret-up", color: "primary", size: "small", turn: isCalendarVisible }))),
    index$1.h("div", { class: Object.assign({}, blockNav.modifier('end').class()), style: {
        display: isListVisible ? 'none' : 'flex',
      } },
      index$1.h("button", { title: previousMonthLabel, "aria-label": previousMonthLabel, onClick: onClickPreviousMonth, tabIndex: -1, "data-test": "previous-month" },
        index$1.h("bal-icon", { name: "caret-left", color: "primary", size: "small" })),
      index$1.h("button", { title: nextMonthLabel, "aria-label": nextMonthLabel, onClick: onClickNextMonth, tabIndex: -1, "data-test": "next-month" },
        index$1.h("bal-icon", { name: "caret-right", color: "primary", size: "small" })))));
};

const balDateCalendarCss = ":host{--bal-date-first-week-day:0;--bal-date-calendar-background:var(--bal-color-red-3)}:host{--bal-date-first-week-day:0;--bal-date-calendar-background:var(--bal-color-red-3)}:host{-webkit-touch-callout:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:inline-block;background:var(--bal-color-white);border-radius:var(--bal-radius-normal)}.bal-date-calendar__nav{display:-ms-flexbox;display:flex;width:calc(100% - 1rem);-ms-flex-pack:justify;justify-content:space-between;-ms-flex-align:center;align-items:center;padding:.5rem;gap:.5rem}.bal-date-calendar__nav--start>button{display:-ms-flexbox;display:flex;gap:.5rem}.bal-date-calendar__nav--end{display:-ms-flexbox;display:flex;gap:.5rem}.bal-date-calendar__nav button{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-radius:var(--bal-radius-normal);font-family:var(--bal-font-family-text);font-weight:var(--bal-weight-regular);color:var(--bal-color-text-primary);border:none;background:rgba(0,0,0,0);text-align:center;font-size:var(--bal-size-normal);line-height:var(--bal-line-height-normal);-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;outline:none;min-height:2rem;min-width:2rem;padding:.25rem;border-radius:var(--bal-button-radius);font-family:var(--bal-font-family-title);font-weight:var(--bal-weight-bold)}@media (hover: hover)and (pointer: fine){.bal-date-calendar__nav button:not(.bal-date-calendar__nav button--selected):not(.bal-date-calendar__nav button--disabled):hover{background:var(--bal-color-light-blue-1)}}.bal-date-calendar__nav button:not(.bal-date-calendar__nav button--selected):not(.bal-date-calendar__nav button--disabled):active{background:var(--bal-color-light-blue-2)}.bal-date-calendar__nav button--today:not(.bal-date-calendar__nav button--selected):not(.bal-date-calendar__nav button--disabled){color:var(--bal-color-light-blue-3);font-weight:var(--bal-weight-bold)}@media (hover: hover)and (pointer: fine){.bal-date-calendar__nav button--today:not(.bal-date-calendar__nav button--selected):not(.bal-date-calendar__nav button--disabled):hover{color:var(--bal-color-text-primary)}}.bal-date-calendar__nav button--today:not(.bal-date-calendar__nav button--selected):not(.bal-date-calendar__nav button--disabled):active{color:var(--bal-color-text-primary)}.bal-date-calendar__nav button--selected{background:var(--bal-color-primary);color:var(--bal-color-text-white);font-weight:var(--bal-weight-bold)}.bal-date-calendar__nav button--disabled{cursor:default;background:rgba(0,0,0,0);color:var(--bal-color-text-grey-light)}.bal-date-calendar__body{display:block}.bal-date-calendar__body__grid{width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;padding:.5rem;height:0;padding-top:0;padding-bottom:0;visibility:hidden}.bal-date-calendar__body__grid--visible{height:auto;padding-top:.5rem;padding-bottom:.5rem;visibility:visible}.bal-date-calendar__body__grid__head{position:relative;display:grid;grid-template-columns:repeat(7, 1fr);-webkit-column-gap:.5rem;-moz-column-gap:.5rem;column-gap:.5rem;row-gap:.5rem;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.bal-date-calendar__body__grid__head::after{position:absolute;content:\"\";height:2px;width:calc(100% + 1rem);bottom:0;left:-0.5rem;right:-0.5rem;background:var(--bal-color-border-grey)}.bal-date-calendar__body__grid__head span{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;height:2rem;width:2rem;font-family:var(--bal-font-family-title);font-weight:var(--bal-weight-bold);font-size:var(--bal-size-normal);line-height:var(--bal-line-height-normal);-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}.bal-date-calendar__body__grid__body{display:grid;grid-template-columns:repeat(7, 1fr);-webkit-column-gap:.5rem;-moz-column-gap:.5rem;column-gap:.5rem;row-gap:.5rem;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content;padding-top:.5rem}.bal-date-calendar__body__grid__body>.bal-date-calendar-cell{width:2rem;height:2rem;text-align:center;font-size:var(--bal-size-normal);line-height:var(--bal-line-height-normal);-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto}.bal-date-calendar__body__grid__body>.bal-date-calendar-cell:first-child{grid-column:var(--bal-date-first-week-day)}.bal-date-calendar__body__list{display:none;list-style:none;margin:0;padding:0;-webkit-column-gap:.5rem;-moz-column-gap:.5rem;column-gap:.5rem;row-gap:.5rem;width:calc(100% - 1rem);overflow-y:auto;max-height:18rem;position:relative;padding:.5rem;border-top:2px solid var(--bal-color-border-grey)}.bal-date-calendar__body__list .bal-date-calendar__body__list__item{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-radius:var(--bal-radius-normal);font-family:var(--bal-font-family-text);font-weight:var(--bal-weight-regular);color:var(--bal-color-text-primary);border:none;background:rgba(0,0,0,0);text-align:center;font-size:var(--bal-size-normal);line-height:var(--bal-line-height-normal);-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;outline:none;width:100%}@media (hover: hover)and (pointer: fine){.bal-date-calendar__body__list .bal-date-calendar__body__list__item:not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--selected):not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--disabled):hover{background:var(--bal-color-light-blue-1)}}.bal-date-calendar__body__list .bal-date-calendar__body__list__item:not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--selected):not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--disabled):active{background:var(--bal-color-light-blue-2)}.bal-date-calendar__body__list .bal-date-calendar__body__list__item--today:not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--selected):not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--disabled){color:var(--bal-color-light-blue-3);font-weight:var(--bal-weight-bold)}@media (hover: hover)and (pointer: fine){.bal-date-calendar__body__list .bal-date-calendar__body__list__item--today:not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--selected):not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--disabled):hover{color:var(--bal-color-text-primary)}}.bal-date-calendar__body__list .bal-date-calendar__body__list__item--today:not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--selected):not(.bal-date-calendar__body__list .bal-date-calendar__body__list__item--disabled):active{color:var(--bal-color-text-primary)}.bal-date-calendar__body__list .bal-date-calendar__body__list__item--selected{background:var(--bal-color-primary);color:var(--bal-color-text-white);font-weight:var(--bal-weight-bold)}.bal-date-calendar__body__list .bal-date-calendar__body__list__item--disabled{cursor:default;background:rgba(0,0,0,0);color:var(--bal-color-text-grey-light)}.bal-date-calendar__body__list--visible{display:grid}.bal-date-calendar__body__list--year{grid-template-columns:repeat(4, 1fr)}.bal-date-calendar__body__list--month{grid-template-columns:repeat(2, 1fr)}.bal-date-calendar-cell{display:-ms-flexbox;display:flex;-ms-flex-pack:center;justify-content:center;-ms-flex-align:center;align-items:center;cursor:pointer;border-radius:var(--bal-radius-normal);font-family:var(--bal-font-family-text);font-weight:var(--bal-weight-regular);color:var(--bal-color-text-primary);border:none;background:rgba(0,0,0,0);text-align:center;font-size:var(--bal-size-normal);line-height:var(--bal-line-height-normal);-webkit-hyphens:auto;-ms-hyphens:auto;hyphens:auto;outline:none;width:2rem;height:2rem}@media (hover: hover)and (pointer: fine){.bal-date-calendar-cell:not(.bal-date-calendar-cell--selected):not(.bal-date-calendar-cell--disabled):hover{background:var(--bal-color-light-blue-1)}}.bal-date-calendar-cell:not(.bal-date-calendar-cell--selected):not(.bal-date-calendar-cell--disabled):active{background:var(--bal-color-light-blue-2)}.bal-date-calendar-cell--today:not(.bal-date-calendar-cell--selected):not(.bal-date-calendar-cell--disabled){color:var(--bal-color-light-blue-3);font-weight:var(--bal-weight-bold)}@media (hover: hover)and (pointer: fine){.bal-date-calendar-cell--today:not(.bal-date-calendar-cell--selected):not(.bal-date-calendar-cell--disabled):hover{color:var(--bal-color-text-primary)}}.bal-date-calendar-cell--today:not(.bal-date-calendar-cell--selected):not(.bal-date-calendar-cell--disabled):active{color:var(--bal-color-text-primary)}.bal-date-calendar-cell--selected{background:var(--bal-color-primary);color:var(--bal-color-text-white);font-weight:var(--bal-weight-bold)}.bal-date-calendar-cell--disabled{cursor:default;background:rgba(0,0,0,0);color:var(--bal-color-text-grey-light)}";

var __decorate$1 = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const DateCalendar = class {
  constructor(hostRef) {
    index$1.registerInstance(this, hostRef);
    this.balChange = index$1.createEvent(this, "balChange", 7);
    this.onSelectDay = (isoDate) => {
      this.valueChanged(isoDate, this.selectedDate);
      this.balChange.emit(this.selectedDate);
    };
    this.onClickNextMonth = () => {
      let nextYear = this.year;
      let nextMonth = this.month + 1;
      if (nextMonth > 12) {
        nextMonth = 1;
        nextYear = nextYear + 1;
      }
      this.generateGridByMonthAndYear(nextMonth, nextYear);
    };
    this.onClickPreviousMonth = () => {
      let nextYear = this.year;
      let nextMonth = this.month - 1;
      if (nextMonth < 1) {
        nextMonth = 12;
        nextYear = nextYear - 1;
      }
      this.generateGridByMonthAndYear(nextMonth, nextYear);
    };
    this.onClickSelectMonthAndYear = async () => {
      if (this.isCalendarVisible === true) {
        this.isCalendarVisible = false;
        this.isYearListVisible = true;
        this.isMonthListVisible = false;
        await helpers.waitAfterFramePaint();
        if (this.yearListEl) {
          const selectedYearEl = this.yearListEl.querySelector(`#year-${this.year}`);
          if (selectedYearEl) {
            const rowHeight = 26 + 8 + 4;
            this.yearListEl.scrollTop = selectedYearEl.offsetTop - rowHeight * 2;
          }
          else {
            this.yearListEl.scrollTop = 0;
          }
        }
      }
      else {
        this.isCalendarVisible = true;
        this.isYearListVisible = false;
        this.isMonthListVisible = false;
      }
    };
    this.onClickYear = (newYear) => {
      this.isYearListVisible = false;
      this.isMonthListVisible = true;
      this.generateGridByMonthAndYear(this.month, newYear);
    };
    this.onClickMonth = (newMonth) => {
      this.isYearListVisible = false;
      this.isMonthListVisible = false;
      this.isCalendarVisible = true;
      this.generateGridByMonthAndYear(newMonth, this.year);
    };
    this.selectedDate = '';
    this.monthFullNames = [];
    this.weekdays = [];
    this.months = [];
    this.years = [];
    this.calendarGrid = [];
    this.firstDayOfWeek = 0;
    this.month = 0;
    this.year = 0;
    this.language = initialize.defaultConfig.language;
    this.isCalendarVisible = true;
    this.isYearListVisible = false;
    this.isMonthListVisible = false;
    this.value = undefined;
    this.defaultDate = undefined;
    this.allowedDates = undefined;
    this.min = undefined;
    this.max = undefined;
    this.minYearProp = undefined;
    this.maxYearProp = undefined;
  }
  createLogger(log) {
    this.log = log;
  }
  valueChanged(newValue, oldValue) {
    if (newValue !== oldValue) {
      const date$1 = date.BalDate.fromISO(newValue);
      if (!date$1.isValid) {
        this.generateGridByDefaultDate();
        this.selectedDate = '';
      }
      else {
        this.generateGridByDate(date$1);
        this.selectedDate = date$1.toISODate();
      }
    }
  }
  rangePropChanged() {
    this.months = generateMonths(this.language, this.year, this.min, this.max);
    this.years = generateYears(this.minYear, this.maxYear);
  }
  yearRangePropChanged() {
    this.years = generateYears(this.minYear, this.maxYear);
  }
  connectedCallback() {
    this.generateGridByDefaultDate();
    this.valueChanged(this.value, undefined);
  }
  async configChanged(state) {
    this.years = generateYears(this.minYear, this.maxYear);
    this.months = generateMonths(state.language, this.year, this.min, this.max);
    this.weekdays = generateWeekDays(state.language);
    this.monthFullNames = date.BalDate.infoMonths({ format: 'long', locale: this.language });
    this.language = state.language;
  }
  swipeListener({ left, right }) {
    if (left) {
      this.onClickNextMonth();
    }
    else if (right) {
      this.onClickPreviousMonth();
    }
  }
  get minYear() {
    if (this.minYearProp === undefined) {
      const today = new Date();
      const year = today.getFullYear();
      const defaultMinYear = year - 100;
      if (this.min) {
        const date$1 = date.BalDate.fromISO(this.min);
        return date$1.year || defaultMinYear;
      }
      else {
        return defaultMinYear;
      }
    }
    return this.minYearProp;
  }
  get maxYear() {
    if (this.maxYearProp === undefined) {
      const today = new Date();
      const year = today.getFullYear();
      const defaultMaxYear = year + 50;
      if (this.max) {
        const date$1 = date.BalDate.fromISO(this.max);
        return date$1.year || defaultMaxYear;
      }
      else {
        return defaultMaxYear;
      }
    }
    return this.maxYearProp;
  }
  generateGridByDate(date) {
    if (date.year !== undefined && date.month !== undefined) {
      this.generateGridByMonthAndYear(date.month, date.year);
    }
  }
  generateGridByDefaultDate() {
    const date$1 = date.BalDate.fromISO(this.defaultDate);
    if (date$1.isValid) {
      this.generateGridByDate(date$1);
    }
    else {
      const today = new Date();
      this.month = today.getMonth() + 1;
      this.year = today.getFullYear();
      this.calendarGrid = generateCalendarGrid(this.year, this.month, this.min, this.max, this.allowedDates);
      this.firstDayOfWeek = getFirstWeekdayOfMonth(this.year, this.month);
    }
  }
  generateGridByMonthAndYear(month, year) {
    if (this.month !== month || this.year !== year) {
      this.calendarGrid = generateCalendarGrid(year, month, this.min, this.max, this.allowedDates);
      this.firstDayOfWeek = getFirstWeekdayOfMonth(year, month);
    }
    this.month = month;
    this.year = year;
  }
  render() {
    var _a;
    const today = new Date();
    const todayYear = today.getFullYear();
    const todayMonth = today.getMonth() + 1;
    const girdHeight = ((_a = this.gridEl) === null || _a === void 0 ? void 0 : _a.clientHeight) || 0;
    const block = bem.BEM.block('date-calendar');
    const blockBody = block.element('body');
    const blockFoot = block.element('foot');
    return (index$1.h(index$1.Host, { class: Object.assign({}, block.class()) }, index$1.h(CalendarNav, { language: this.language, monthFullNames: this.monthFullNames, month: this.month, year: this.year, isCalendarVisible: this.isCalendarVisible, isListVisible: this.isMonthListVisible || this.isYearListVisible, onClickSelectMonthAndYear: this.onClickSelectMonthAndYear, onClickPreviousMonth: this.onClickPreviousMonth, onClickNextMonth: this.onClickNextMonth }), index$1.h("div", { class: Object.assign({}, blockBody.class()) }, index$1.h(CalendarGrid, { isVisible: this.isCalendarVisible, grid: this.calendarGrid, weekdays: this.weekdays, firstDayOfWeek: this.firstDayOfWeek, selectedDate: this.selectedDate, ref: el => (this.gridEl = el), onSelectDay: isoDate => this.onSelectDay(isoDate) }), index$1.h(CalendarList, { name: "year", isVisible: this.isYearListVisible, girdHeight: girdHeight, todayValue: todayYear, selectedValue: this.year, list: this.years, ref: el => (this.yearListEl = el), onSelect: item => this.onClickYear(item.value) }), index$1.h(CalendarList, { name: "month", isVisible: this.isMonthListVisible, girdHeight: girdHeight, todayValue: todayMonth, selectedValue: this.month, list: this.months, onSelect: item => this.onClickMonth(item.value) })), index$1.h("div", { class: Object.assign({}, blockFoot.class()) }, index$1.h("slot", null))));
  }
  get el() { return index$1.getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"],
    "min": ["rangePropChanged"],
    "max": ["rangePropChanged"],
    "minYearProp": ["yearRangePropChanged"],
    "maxYearProp": ["yearRangePropChanged"]
  }; }
};
__decorate$1([
  log.Logger('bal-date-calendar')
], DateCalendar.prototype, "createLogger", null);
__decorate$1([
  config_decorator.ListenToConfig()
], DateCalendar.prototype, "configChanged", null);
__decorate$1([
  swipe_decorator.ListenToSwipe({ mobileOnly: true })
], DateCalendar.prototype, "swipeListener", null);
DateCalendar.style = balDateCalendarCss;

class MaskPosition {
  constructor(_options) {
    this._options = _options;
    this._position = 0;
    this._positionEnd = 0;
    this._isRangeSelection = false;
    if (_options.component && _options.component.nativeInput) {
      this._position = _options.component.nativeInput.selectionStart || 0;
      this._positionEnd = _options.component.nativeInput.selectionEnd || 0;
      this._isRangeSelection = this._position !== this._positionEnd;
    }
  }
  get isRangeSelection() {
    return this._isRangeSelection;
  }
  get value() {
    if (this._options.isBackspace && this._position > 0) {
      return this._position - 1;
    }
    return this._position;
  }
  set value(index) {
    const validatedIndex = index < 0 ? 0 : index > this._options.mask.maxLength ? this._options.mask.maxLength : index;
    this._position = validatedIndex;
  }
  toStart() {
    this.value = 0;
  }
  toEnd() {
    const target = this.getTarget();
    if (target) {
      this.value = target.value.length;
    }
  }
  next(next = 1) {
    const newPosition = this._position + next;
    if (newPosition <= this._options.mask.maxLength) {
      this._position = newPosition;
    }
    return this._position;
  }
  previous(previous = 1) {
    const newPosition = this._position - previous;
    if (newPosition >= 0) {
      this._position = newPosition;
    }
    else {
      this._position = 0;
    }
    return this._position;
  }
  submit() {
    const target = this.getTarget();
    if (target && target.selectionStart !== this._position && target.selectionEnd !== this._position) {
      target.selectionStart = this._position;
      target.selectionEnd = this._position;
    }
  }
  getTarget() {
    if (this._options.component && this._options.component.nativeInput) {
      return this._options.component.nativeInput;
    }
    return undefined;
  }
}

class MaskContext {
  constructor(_options) {
    this._options = _options;
    this._value = '';
    if (this._options.component && this._options.component.nativeInput) {
      this._value = this._options.component.nativeInput.value;
    }
    this.position = new MaskPosition(this._options);
  }
  get target() {
    if (this._options.component && this._options.component.nativeInput) {
      return this._options.component.nativeInput;
    }
    return undefined;
  }
  get value() {
    return this._value;
  }
  set value(newValue) {
    this._value = newValue;
  }
  get focused() {
    return this._options.component.focused;
  }
  isValueEmpty() {
    return this.value === '' || this.value === undefined || this.value === null;
  }
  preventDefault() {
    if (this._options.event.preventDefault) {
      this._options.event.preventDefault();
    }
  }
  stopPropagation() {
    this.preventDefault();
    if (this._options.event.stopPropagation) {
      this._options.event.stopPropagation();
    }
  }
  async submit(eventType = 'input', parsedValue) {
    if (this.target) {
      this.target.value = this.value;
      if (eventType !== 'blur' && eventType !== 'tab') {
        this.position.submit();
      }
      if (this._options.component) {
        if (eventType === 'input' || eventType === 'tab') {
          this._options.component.balInput.emit(this.value);
        }
        if ((eventType === 'change' || eventType === 'blur') && parsedValue !== undefined) {
          const valueChanged = this._options.component.value !== parsedValue;
          if (valueChanged) {
            this._options.component.value = parsedValue;
            this._options.component.balChange.emit(parsedValue);
          }
        }
      }
    }
  }
}

class MaskClipboardContext extends MaskContext {
  get clipboardData() {
    var _a;
    return (_a = this._options.event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text');
  }
}

class MaskFocusContext extends MaskContext {
}

class MaskKeyboardContext extends MaskContext {
  get key() {
    return this._options.event.key;
  }
  get isCtrlOrCommandKey() {
    return this._options.event.metaKey || this._options.event.ctrlKey;
  }
  get isBackspaceKey() {
    return this._options.event.key === 'Backspace';
  }
  get isWhiteSpaceKey() {
    return this._options.event.key === ' ';
  }
  get isDeleteKey() {
    return this._options.event.key === 'Delete' || this._options.event.key === 'Del';
  }
  get isNumberKey() {
    return MaskKeyboardContext.NUMBER_KEYS.includes(this._options.event.key);
  }
  get isNavigationKey() {
    return MaskKeyboardContext.NAVIGATION_KEYS.includes(this._options.event.key);
  }
  get isSelectAllCommand() {
    return (this._options.event.ctrlKey || this._options.event.metaKey) && this.key === 'a';
  }
  get isCopyCommand() {
    return (this._options.event.ctrlKey || this._options.event.metaKey) && this.key === 'c';
  }
  get isPasteCommand() {
    return (this._options.event.ctrlKey || this._options.event.metaKey) && this.key === 'v';
  }
  getCharAt(position = this.position.value) {
    return this.value.charAt(position);
  }
  getCharAtBackspacePosition() {
    return this.getCharAt(this.position.value - 1);
  }
  setChar(char = this._options.event.key, position = this.position.value) {
    this.value = this.value.substring(0, position) + char + this.value.substring(position + 1);
  }
}
MaskKeyboardContext.NUMBER_KEYS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
MaskKeyboardContext.NAVIGATION_KEYS = [
  'Home',
  'End',
  'ArrowLeft',
  'Left',
  'ArrowRight',
  'Right',
  'Tab',
  'Enter',
  'Esc',
  'Escape',
];

class MaskLocaleContext extends MaskContext {
  get locale() {
    return this._options.event.locale;
  }
}

class MaskMouseContext extends MaskContext {
}

class MaskValueChangedContext extends MaskContext {
  get newValue() {
    return this._options.event.newValue;
  }
  get oldValue() {
    return this._options.event.oldValue;
  }
  get didValueChange() {
    return this.newValue !== this.oldValue;
  }
}

class MaskBlock {
  constructor(option) {
    this._isSeparator = false;
    this._allowedKeys = [];
    this._locale = 'de-CH';
    this._from = option.from || 0;
    this._to = option.to || 0;
    this._isSeparator = option.isSeparator === undefined ? false : option.isSeparator;
    this._mask = option.mask || '_';
    this._allowedKeys = option.allowedKeys ? option.allowedKeys : this.allowedKeys;
    this._format = option.format;
  }
  format(value) {
    if (this._format) {
      return this._format(value.replace(this.mask, ''), this._locale, this.mask);
    }
    return value;
  }
  get isSeparator() {
    return this._isSeparator;
  }
  get to() {
    return this._to;
  }
  get from() {
    return this._from;
  }
  get mask() {
    if (index$2.lodash_isfunction(this._mask)) {
      return this._mask(this._locale);
    }
    return this._mask;
  }
  get allowedKeys() {
    return this._allowedKeys;
  }
  onI18nChange(locale) {
    this._locale = locale;
  }
  getValueOfTheBlock(value) {
    return value.slice(this._from, this._to);
  }
  isTouched(value) {
    const blockValue = this.getValueOfTheBlock(value);
    return !blockValue.split('').every(char => char === this.mask);
  }
  verifyAllowedKeyHits(key) {
    if (this.isSeparator && key === this.mask) {
      return true;
    }
    else if (this.allowedKeys.indexOf(key) >= 0) {
      return true;
    }
    else {
      return false;
    }
  }
}

class MaskBlockList {
  constructor(_list = []) {
    this._list = _list;
  }
  get lastPosition() {
    return this._list[this._list.length - 1].to;
  }
  get list() {
    return this._list;
  }
  set list(list) {
    this._list = list;
  }
  clone() {
    return new MaskBlockList([...this._list]);
  }
  findByIndex(index, blocks = this.list) {
    return blocks.find(block => block.from <= index && index < block.to);
  }
  getPlaceholderMask() {
    const placeholder = [];
    this.list.forEach(block => {
      const length = block.to - block.from;
      for (let index = 0; index < length; index++) {
        placeholder.push(block.mask);
      }
    });
    return placeholder.join('');
  }
  getRawValueWithoutMaskByContext(context) {
    return this.getRawValueWithoutMask(context.value);
  }
  getRawValueWithoutMask(value) {
    if (value) {
      let rawValue = [];
      const chars = value.split('');
      for (let index = 0; index < chars.length; index++) {
        const char = chars[index];
        const block = this.findByIndex(index);
        if (block && !block.isSeparator) {
          rawValue.push(char.replace(block.mask, ''));
        }
        else {
          rawValue.push(char);
        }
      }
      rawValue = rawValue.filter(v => v);
      const amountSeparators = this.list.filter(block => block.isSeparator).length;
      if (amountSeparators === rawValue.length) {
        return '';
      }
      return rawValue.join('');
    }
    return '';
  }
  formatBlocks(value, activeBlockIndex) {
    let newValue = `${value}`;
    for (let index = 0; index < this.list.length; index++) {
      const block = this.list[index];
      if (activeBlockIndex !== index && !block.isSeparator && block.isTouched(newValue)) {
        const blockValue = block.getValueOfTheBlock(newValue);
        const newBlockValue = block.format(blockValue);
        newValue = newValue.substring(0, block.from) + newBlockValue + newValue.substring(block.to);
      }
    }
    return newValue;
  }
  getBlockIndexFromPosition(position) {
    const length = this.list.reduce((acc, block) => acc + block.to - block.from, 0);
    if (position === length) {
      return this.list.length - 1;
    }
    const index = this.list.findIndex(block => block.from <= position && position < block.to);
    return index < 0 ? undefined : Math.min(length, index);
  }
  verifyCallOfNextSeparator(key, index) {
    if (this.list.length - 1 > index) {
      const nextBlock = this.list[index + 1];
      if (nextBlock.isSeparator && nextBlock.mask === key) {
        return true;
      }
    }
    return false;
  }
}

class AbstractMask {
  constructor(blocks = []) {
    this.inputMode = 'text';
    this.locale = 'de-CH';
    this.blocks = new MaskBlockList(blocks);
  }
  onLocaleChange(context, _oldLocale, oldBlocks) {
    if (context.target) {
      const value = context.value;
      const chars = value.split('');
      for (let index = 0; index < chars.length; index++) {
        const char = chars[index];
        const newBlock = this.blocks.findByIndex(index);
        const oldBlock = oldBlocks.findByIndex(index);
        if (newBlock && oldBlock) {
          if (newBlock.isSeparator) {
            chars[index] = newBlock.mask;
          }
          else if (char === oldBlock.mask) {
            chars[index] = newBlock.mask;
          }
        }
      }
      context.value = chars.join('');
    }
  }
  onFocus(_context) {
  }
  onBlur(_context) {
  }
  onChange(context) {
    context.submit('change', this.onParseValue(context.value));
  }
  onNavigationDown(_context, _block, _index) {
  }
  onSelectAll(_context, _block, _index) {
  }
  onPaste(context, _block, _index) {
    const value = context.clipboardData || '';
    context.value = value;
    context.position.toEnd();
  }
  onBlockChange(context, block, index) {
    context.setChar();
    context.position.next();
    const nextBlock = this.blocks.list[index + 1];
    if (context.position.value === block.to && nextBlock && nextBlock.isSeparator) {
      context.position.next();
    }
  }
  onBackspaceDown(context, block, index) {
    context.position.previous();
    if (!block.isSeparator) {
      context.setChar(block.mask);
      const previousBlock = this.blocks.list[index - 1];
      if (context.position.value === block.from && previousBlock && previousBlock.isSeparator) {
        context.position.previous();
      }
    }
  }
  onDeleteDown(context, block, index) {
    context.setChar(block.mask);
    context.position.next();
    const nextBlock = this.blocks.list[index + 1];
    if (context.position.value === block.to && nextBlock && nextBlock.isSeparator) {
      context.position.next();
    }
  }
  onValueChanged(context) {
    const formattedValue = this.onFormatValue(context.newValue);
    const inputValue = context.focused && formattedValue === '' ? this.blocks.getPlaceholderMask() : formattedValue;
    context.value = inputValue;
    context.position.toEnd();
  }
  onParseValue(inputValue) {
    if (inputValue) {
      return inputValue.trim();
    }
    return inputValue || '';
  }
  onFormatValue(rawValue) {
    if (rawValue) {
      return rawValue.trim();
    }
    return rawValue || '';
  }
  fireI18nChange(context) {
    const oldBlocks = this.blocks.clone();
    const oldLocale = `${context.locale}`;
    this.locale = context.locale;
    this.blocks.list.forEach(block => block.onI18nChange(context.locale));
    this.onLocaleChange(context, oldLocale, oldBlocks);
  }
  fireValueChanged(context) {
    if (context.didValueChange) {
      this.onValueChanged(context);
    }
  }
  firePaste(context) {
    const index = this.blocks.getBlockIndexFromPosition(context.position.value);
    if (index !== undefined) {
      const currentBlock = this.blocks.list[index];
      this.onPaste(context, currentBlock, index);
      this.onChange(context);
    }
  }
  fireClick(context) {
    const maskPlaceholder = this.blocks.getPlaceholderMask();
    if (maskPlaceholder === context.value) {
      context.position.toStart();
    }
  }
  fireFocus(context) {
    if (context.target && context.isValueEmpty()) {
      this.resetInputValueWithMask(context);
    }
    this.onFocus(context);
  }
  fireBlur(context) {
    if (context.target) {
      if (this.isValueEmptyMask(context)) {
        this.emptyInputValue(context);
      }
      else {
        this.onBlur(context);
        context.submit('blur', this.onParseValue(context.value));
      }
    }
  }
  fireKeyDown(context) {
    const position = context.isBackspaceKey ? Math.max(0, context.position.value - 1) : context.position.value;
    const index = this.blocks.getBlockIndexFromPosition(position);
    if (position >= this.blocks.lastPosition && !context.isNavigationKey && !context.isSelectAllCommand) {
      context.preventDefault();
      context.stopPropagation();
      return;
    }
    if (index !== undefined && !context.position.isRangeSelection) {
      const currentBlock = this.blocks.list[index];
      if (context.isNavigationKey) {
        this.onNavigationDown(context, currentBlock, index);
      }
      else if (context.isSelectAllCommand) {
        this.onSelectAll(context, currentBlock, index);
      }
      else if (context.isCopyCommand) ;
      else if (context.isPasteCommand) ;
      else if (context.isBackspaceKey) {
        context.preventDefault();
        this.onBackspaceDown(context, currentBlock, index);
      }
      else if (context.isDeleteKey) {
        context.preventDefault();
        this.onDeleteDown(context, currentBlock, index);
      }
      else if (context.isWhiteSpaceKey) {
        context.preventDefault();
        const lastWrittenChar = context.value[context.position.value];
        if (lastWrittenChar === '.') {
          context.stopPropagation();
          const value = context.value;
          context.value = value.substring(0, context.position.value) + '_' + value.substring(context.position.value + 1);
        }
      }
      else if (currentBlock.verifyAllowedKeyHits(context.key)) {
        context.preventDefault();
        this.onBlockChange(context, currentBlock, index);
      }
      else if (this.blocks.verifyCallOfNextSeparator(context.key, index)) {
        context.preventDefault();
        const activeBlock = this.blocks.list[index];
        if (context.position.value > activeBlock.from) {
          const nextBlock = this.blocks.list[index + 1];
          const value = context.value;
          const blockValue = currentBlock.getValueOfTheBlock(value);
          const newBlockValue = currentBlock.format(blockValue);
          context.value = value.substring(0, currentBlock.from) + newBlockValue + value.substring(currentBlock.to);
          context.position.value = nextBlock.to;
        }
      }
      const newIndex = this.blocks.getBlockIndexFromPosition(context.position.value);
      if (newIndex && !context.isBackspaceKey) {
        const newFormattedValue = this.blocks.formatBlocks(context.value, newIndex);
        const position = context.position.value;
        context.value = newFormattedValue;
        context.position.value = position;
      }
    }
    else {
      context.preventDefault();
      if (context.isBackspaceKey || context.isDeleteKey) {
        this.resetInputValueWithMask(context);
      }
      else if (this.blocks.list[0].verifyAllowedKeyHits(context.key)) {
        this.onBlockChange(context, this.blocks.list[0], 0);
      }
    }
  }
  resetInputValueWithMask(context) {
    context.value = this.blocks.getPlaceholderMask();
    context.position.toStart();
  }
  isValueEmptyMask(context) {
    const placeholder = this.blocks.getPlaceholderMask();
    return placeholder === context.value;
  }
  emptyInputValue(context) {
    context.value = '';
    context.submit('blur', context.value);
  }
}

class DateMask extends AbstractMask {
  constructor() {
    super([
      new MaskBlock({
        from: 0,
        to: 2,
        allowedKeys: [...keys_constant.NUMBER_KEYS],
        format: (value, _locale, mask) => {
          if (Number.isNaN(parseInt(value, 10))) {
            return `${mask}${mask}`;
          }
          return value.padStart(2, '0');
        },
        mask: locale => {
          return this.dayMask[locale.split('-')[0]] || this.dayMask['de'];
        },
      }),
      new MaskBlock({ from: 2, to: 3, mask: locale => index_esm.dateSeparator(locale), isSeparator: true }),
      new MaskBlock({
        from: 3,
        to: 5,
        allowedKeys: [...keys_constant.NUMBER_KEYS],
        format: (value, _locale, mask) => {
          if (Number.isNaN(parseInt(value, 10))) {
            return `${mask}${mask}`;
          }
          return value.padStart(2, '0');
        },
        mask: locale => this.monthMask[locale.split('-')[0]] || this.monthMask['de'],
      }),
      new MaskBlock({ from: 5, to: 6, mask: locale => index_esm.dateSeparator(locale), isSeparator: true }),
      new MaskBlock({
        from: 6,
        to: 10,
        allowedKeys: [...keys_constant.NUMBER_KEYS],
        mask: locale => this.yearMask[locale.split('-')[0]] || this.yearMask['de'],
      }),
    ]);
    this.maxLength = 10;
    this.minLength = 10;
    this.dayMask = {
      de: 'T',
      en: 'D',
      fr: 'J',
      it: 'G',
      nl: 'D',
      es: 'D',
      pl: 'D',
      pt: 'D',
      sv: 'D',
      fi: 'M',
    };
    this.monthMask = {
      de: 'M',
      en: 'M',
      fr: 'M',
      it: 'M',
      nl: 'M',
      es: 'M',
      pl: 'M',
      pt: 'M',
      sv: 'M',
      fi: 'K',
    };
    this.yearMask = {
      de: 'J',
      en: 'Y',
      fr: 'A',
      it: 'A',
      nl: 'J',
      es: 'A',
      pl: 'R',
      pt: 'A',
      sv: 'Å',
      fi: 'V',
    };
  }
  onParseValue(inputValue) {
    if (inputValue) {
      const date$1 = date.BalDate.fromAnyFormat(this.blocks.getRawValueWithoutMask(inputValue));
      if (date$1.isValid) {
        return date$1.toISODate();
      }
    }
    return '';
  }
  onFormatValue(isoDate) {
    if (isoDate) {
      const date$1 = date.BalDate.fromISO(isoDate);
      if (date$1.isValid) {
        return date$1.toFormat();
      }
    }
    return '';
  }
  onPaste(context, _block, _index) {
    const value = context.clipboardData || '';
    const date$1 = date.BalDate.fromAnyFormat(value);
    if (date$1.isValid) {
      context.value = date$1.toFormat();
      context.position.toEnd();
    }
  }
  onBlur(context) {
    const rawValue = this.blocks.getRawValueWithoutMaskByContext(context);
    const date$1 = date.BalDate.fromAnyFormat(rawValue);
    if (date$1.isValid) {
      const formattedDate = date$1.toFormat();
      if (formattedDate !== context.value) {
        context.value = formattedDate;
      }
    }
  }
}

class MaskComponentAdapter {
  constructor(mask) {
    this.mask = mask;
  }
  get attributes() {
    return {
      inputMode: this.mask.inputMode,
      maxLength: this.mask.maxLength,
      minLength: this.mask.minLength,
      type: 'text',
      autoCapitalize: 'off',
      autoCorrect: 'off',
      spellcheck: false,
    };
  }
  bindComponent(component) {
    this.component = component;
  }
  bindComponentDidLoad() {
    if (this.component && this.component.nativeInput) {
      this.component.nativeInput.value = this.component.value || '';
    }
    this.bindValueChanged(this.component.value, undefined);
  }
  bindConfigChanged(config) {
    const { component, mask } = this;
    const context = new MaskLocaleContext({
      component,
      mask,
      event: {
        locale: `${config.language}-${config.region}`,
      },
    });
    this.mask.fireI18nChange(context);
    context.submit();
  }
  bindValueChanged(newValue, oldValue) {
    const { component, mask } = this;
    const context = new MaskValueChangedContext({
      component,
      mask,
      event: { newValue, oldValue },
    });
    this.mask.fireValueChanged(context);
    context.submit('blur');
  }
  bindKeyDown(event) {
    if (this.isComponentAccessible) {
      const { component, mask } = this;
      const context = new MaskKeyboardContext({ event, component, mask });
      this.mask.fireKeyDown(context);
      const isTabKey = event.key === 'Tab';
      context.submit(isTabKey ? 'tab' : 'input');
      component.balKeyPress.emit(event);
    }
  }
  bindFocus(event) {
    if (this.isComponentAccessible) {
      const { component, mask } = this;
      component.focused = true;
      const context = new MaskFocusContext({ event, component, mask });
      this.mask.fireFocus(context);
      context.submit();
      component.balFocus.emit(event);
    }
  }
  bindBlur(event) {
    if (this.isComponentAccessible) {
      const { component, mask } = this;
      component.focused = false;
      const context = new MaskFocusContext({ event, component, mask });
      this.mask.fireBlur(context);
      context.submit('blur');
      component.balBlur.emit(event);
    }
  }
  bindPaste(event) {
    if (this.isComponentAccessible) {
      const { component, mask } = this;
      const context = new MaskClipboardContext({ event, component, mask });
      this.mask.firePaste(context);
      context.submit();
    }
  }
  bindFormReset(event) {
    const formElement = event.target;
    if (formElement && formElement.contains(this.component.el)) {
      this.component.value = this.component.initialValue;
      this.component.inputValue = this.component.initialValue;
      clearTimeout(this.resetHandlerTimer);
      this.resetHandlerTimer = setTimeout(() => {
        if (this.component.nativeInput) {
          this.component.nativeInput.value = this.component.value || '';
        }
      });
    }
  }
  bindClick(event) {
    if (this.isComponentAccessible) {
      const { component, mask } = this;
      const context = new MaskMouseContext({ event, component, mask });
      this.mask.fireClick(context);
      context.submit();
    }
  }
  bindHostClick(event) {
    if (!this.isComponentAccessible) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  bindGlobalClick(event) {
    if (!this.isComponentAccessible) {
      if (event.target && event.target === this.component.el) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  }
  get isComponentAccessible() {
    return !this.component.disabled && !this.component.readonly;
  }
}

const balInputDateCss = ".bal-input-date{display:block;width:100%;-ms-flex:1;flex:1}.bal-input-date input:not(:-moz-placeholder-shown){letter-spacing:.4px}.bal-input-date input:not(:-ms-input-placeholder){letter-spacing:.4px}.bal-input-date input:not(:placeholder-shown){letter-spacing:.4px}";

var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const InputDate = class {
  constructor(hostRef) {
    index$1.registerInstance(this, hostRef);
    this.balKeyPress = index$1.createEvent(this, "balKeyPress", 7);
    this.balChange = index$1.createEvent(this, "balChange", 7);
    this.balInput = index$1.createEvent(this, "balInput", 7);
    this.balBlur = index$1.createEvent(this, "balBlur", 7);
    this.balFocus = index$1.createEvent(this, "balFocus", 7);
    this.inputId = `bal-i-date-${inputDateIds++}`;
    this.inheritedAttributes = {};
    this.maskAdapter = new MaskComponentAdapter(new DateMask());
    this.inputValue = this.value;
    this.initialValue = this.value || '';
    this.focused = false;
    this.isGrouped = false;
    this.ariaForm = form.defaultBalAriaForm;
    this.name = this.inputId;
    this.invalid = false;
    this.required = false;
    this.disabled = false;
    this.readonly = false;
    this.placeholder = undefined;
    this.clickable = false;
    this.autocomplete = 'off';
    this.hasIconRight = false;
    this.value = undefined;
  }
  createLogger(log) {
    this.log = log;
  }
  valueChanged(newValue, oldValue) {
    this.maskAdapter.bindValueChanged(newValue, oldValue);
  }
  connectedCallback() {
    this.maskAdapter.bindComponent(this);
    this.isGrouped = helpers.hasParent('bal-input-group', this.el);
  }
  componentDidLoad() {
    this.maskAdapter.bindComponentDidLoad();
  }
  componentWillRender() {
    this.inheritedAttributes = attributes.inheritAttributes(this.el, ['aria-label', 'tabindex', 'title']);
  }
  async configChanged(config) {
    this.maskAdapter.bindConfigChanged(config);
  }
  resetHandler(event) {
    this.maskAdapter.bindFormReset(event);
  }
  listenOnClick(event) {
    this.maskAdapter.bindGlobalClick(event);
  }
  async setFocus() {
    formInput.inputSetFocus(this);
  }
  async setBlur() {
    formInput.inputSetBlur(this);
  }
  getInputElement() {
    return Promise.resolve(this.nativeInput);
  }
  async setAriaForm(ariaForm) {
    this.ariaForm = Object.assign({}, ariaForm);
  }
  render() {
    const block = bem.BEM.block('input-date');
    return (index$1.h(index$1.Host, { onClick: (event) => this.maskAdapter.bindHostClick(event), class: Object.assign({}, block.class()) }, index$1.h("input", Object.assign({ class: {
        'input': true,
        'is-disabled': this.disabled || this.readonly,
        'is-danger': this.invalid,
        'is-clickable': this.clickable && !(this.disabled || this.readonly),
        'bal-focusable': !this.disabled,
        'has-icon-right': this.hasIconRight,
      }, "data-testid": "bal-date-input", ref: el => (this.nativeInput = el), id: this.ariaForm.controlId || this.inputId, "aria-labelledby": this.ariaForm.labelId, "aria-describedby": this.ariaForm.messageId, "aria-invalid": this.invalid === true ? 'true' : 'false', "aria-disabled": this.disabled ? 'true' : null, required: this.required, disabled: this.disabled, readonly: this.readonly, autoComplete: this.autocomplete }, this.maskAdapter.attributes, this.inheritedAttributes, { placeholder: this.placeholder, value: this.inputValue, onKeyDown: event => this.maskAdapter.bindKeyDown(event), onClick: event => this.maskAdapter.bindClick(event), onFocus: event => this.maskAdapter.bindFocus(event), onBlur: event => this.maskAdapter.bindBlur(event), onPaste: event => this.maskAdapter.bindPaste(event) }))));
  }
  get el() { return index$1.getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"]
  }; }
};
__decorate([
  log.Logger('bal-input-date')
], InputDate.prototype, "createLogger", null);
__decorate([
  config_decorator.ListenToConfig()
], InputDate.prototype, "configChanged", null);
let inputDateIds = 0;
InputDate.style = balInputDateCss;

exports.bal_date_calendar = DateCalendar;
exports.bal_input_date = InputDate;
