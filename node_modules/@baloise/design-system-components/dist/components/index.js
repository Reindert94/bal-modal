export { setAssetPath, setNonce, setPlatformOptions } from '@stencil/core/internal/client';
export { a as attachToConfig, d as detachFromConfig, o as onBalConfigChange, u as updateBalAllowedLanguages, b as updateBalAnimated, c as updateBalIcons, e as updateBalLanguage, f as updateBalRegion, g as useBalConfig } from './index2.js';
export { F as FileUploadRejectionReason } from './bal-file-upload.type.js';
export { i as i18nBalDate } from './bal-date.i18n.js';
export { i as i18nBalClose } from './bal-close.i18n.js';
export { i as i18nBalDatepicker } from './bal-datepicker.i18n.js';
export { i as i18nBalTimeInput } from './bal-time-input.i18n.js';
export { i as i18nBalInputStepper } from './bal-input-stepper.i18n.js';
export { i as i18nBalLabel } from './bal-label.i18n.js';
import { b as balBrowser } from './browser.js';
export { b as balBrowser } from './browser.js';
import { i as initialize } from './initialize.js';
export { d as defaultConfig, i as initialize } from './initialize.js';
import { i as initStyleMode } from './mode.js';
export { i as initStyleMode } from './mode.js';
import { b as balBreakpoints, B as BalWindowResizeListener } from './breakpoints.subject.js';
export { a as balBreakpointSubject, b as balBreakpoints } from './breakpoints.subject.js';
export { n as newBalStepOption } from './bal-step.util.js';
export { n as newBalTabOption } from './bal-tab.util.js';
import { g as getAppRoot, c as componentOnReady } from './helpers.js';
export { c as componentOnReady, e as deepReady, g as getAppRoot, i as isDescendant, s as shallowReady, f as wait, b as waitAfterFramePaint, d as waitAfterIdleCallback, w as waitForComponent, a as waitForDesignSystem } from './helpers.js';
export { s as scrollToFirstInvalidField } from './form.js';
export { B as BalScrollHandler } from './scroll.js';
import { b as balDevice } from './device.js';
export { b as balDevice } from './device.js';
import { S as Subject } from './listener.js';
export { B as BalSwipeSubject } from './swipe.subject.js';
export { B as BalDate } from './date.js';
import { g as getOverlays, a as getOverlay } from './overlays.js';

const i18nBalFieldLabel = {
  de: {
    optional: ' (optional)',
  },
  en: {
    optional: ' (optional)',
  },
  fr: {
    optional: ' (optionnel)',
  },
  it: {
    optional: ' (opzionale)',
  },
  nl: {
    optional: ' (optioneel)',
  },
  es: {
    optional: ' (opcional)',
  },
  pl: {
    optional: ' (opcjonalnie)',
  },
  pt: {
    optional: ' (opcional)',
  },
  sv: {
    optional: ' (frivillig)',
  },
  fi: {
    optional: ' (valinnainen)',
  },
};

class BalNoticeController {
  constructor(options) {
    this.options = options;
    this.container = null;
    this.queue = [];
    this.preQueue = [];
    this.queueLimit = 5;
  }
  create(options) {
    if (balBrowser.hasDocument) {
      this.setupContainer();
      const clone = this.findClone(options);
      if (clone === undefined) {
        const el = document.createElement(this.options.tag);
        Object.assign(el, options);
        el.addEventListener('balClose', ev => {
          this.removeFromQueue(ev.detail);
        });
        this.preQueue.push(el);
        this.updateQueue();
        return el;
      }
      return clone;
    }
  }
  setQueue(queueLimit) {
    this.queueLimit = queueLimit;
  }
  async dismissAll() {
    var _a;
    const elements = (_a = this.container) === null || _a === void 0 ? void 0 : _a.querySelectorAll(this.options.tag);
    if (elements) {
      const closingQueue = [];
      for (let index = 0; index < elements.length; index++) {
        const el = elements[index];
        if (el.close) {
          closingQueue.push(el.close());
        }
      }
      await Promise.all(closingQueue);
    }
  }
  async clearAll() {
    console.warn('[DEPRECATED] - use dismissAll() instead');
    return this.dismissAll();
  }
  findClone(options) {
    for (let index = 0; index < this.queue.length; index++) {
      const el = this.queue[index];
      if (el.message === options.message && el.color === options.color) {
        return el;
      }
    }
    return undefined;
  }
  setupContainer() {
    if (balBrowser.hasDocument) {
      const containerId = `${this.options.tag}-container`;
      this.container = document.getElementById(containerId);
      if (this.container)
        return;
      if (!this.container) {
        this.container = document.createElement('bal-notices');
        this.container.setAttribute('interface', this.options.tag.replace('bal-', ''));
        this.container.id = containerId;
      }
      document.body.appendChild(this.container);
    }
  }
  updateQueue() {
    var _a;
    if (this.queue.length < this.queueLimit) {
      const el = this.preQueue.shift();
      if (el && this.container) {
        this.queue.push(el);
        this.container.insertAdjacentElement('beforeend', el);
      }
    }
    if (this.queue.length === 0) {
      (_a = this.container) === null || _a === void 0 ? void 0 : _a.remove();
    }
  }
  removeFromQueue(toastId) {
    this.queue = this.queue.filter(el => el.id !== toastId);
    setTimeout(() => this.updateQueue(), 0);
  }
}

class BalToastController extends BalNoticeController {
  constructor() {
    super({
      tag: 'bal-toast',
    });
  }
  create(options) {
    return super.create(options);
  }
}
const balToastController = new BalToastController();

class BalSnackbarController extends BalNoticeController {
  constructor() {
    super({
      tag: 'bal-snackbar',
    });
  }
  create(options) {
    return super.create(options);
  }
}
const balSnackbarController = new BalSnackbarController();

const VERSION = '14.1.0';

const initializeBaloiseDesignSystem = (initConfig = {}) => {
  if (balBrowser.hasWindow) {
    const win = window;
    win.BaloiseDesignSystem = win.BaloiseDesignSystem || {};
    initialize(initConfig, win);
    balBreakpoints.detect();
    win.BaloiseDesignSystem.toastController = balToastController;
    win.BaloiseDesignSystem.snackbarController = balSnackbarController;
    win.BaloiseDesignSystem.initialize = () => initialize(win.BaloiseDesignSystem.config, win);
    win.BaloiseDesignSystem.version = VERSION;
    const onReady = () => {
      if (balBrowser.hasDocument) {
        const body = document.querySelector('.bal-body');
        if (body && body.classList) {
          body.classList.add('is-ready');
        }
      }
    };
    if (win.addEventListener) {
      let isAppReady = false;
      let styleMode = 'css';
      const app = document.querySelector('.bal-app');
      if (app) {
        isAppReady = (app === null || app === void 0 ? void 0 : app.getAttribute('ready')) === '';
        if ((app === null || app === void 0 ? void 0 : app.getAttribute('mode')) !== null) {
          styleMode = app === null || app === void 0 ? void 0 : app.getAttribute('mode');
        }
      }
      initStyleMode(styleMode);
      if (isAppReady) {
        onReady();
      }
      else {
        win.addEventListener('balAppLoad', () => onReady());
      }
    }
  }
};

const newBalCheckboxOption = (option) => {
  return Object.assign(Object.assign({ interface: 'checkbox', labelHidden: false, flat: false, disabled: false, readonly: false, required: false, hidden: false, invalid: false, checked: false }, option), { label: '', html: option.label });
};

const newBalRadioOption = (option) => {
  return Object.assign(Object.assign({ interface: 'radio', labelHidden: false, flat: false, disabled: false, readonly: false, required: false, hidden: false, invisible: false, invalid: false }, option), { label: '', html: option.label });
};

const newBalOptionValue = (value, label, disabled = false, data) => {
  return {
    value,
    label,
    disabled,
    data,
  };
};
const newBalSingleOptionValue = (valueAndLabel, disabled = false, data) => {
  return newBalOptionValue(valueAndLabel, valueAndLabel, disabled, data);
};

class BalOrientationSubject extends Subject {
  constructor() {
    super(observer => observer.orientationListener(this.state));
    this.listener = new BalWindowResizeListener();
    this.state = balDevice.orientation.toObject();
    this.listener.connect();
    this.listener.add(() => {
      const newState = balDevice.orientation.toObject();
      if (!this.isEqual(newState)) {
        this.state = newState;
        this.notify(undefined);
      }
    });
  }
  attach(observer) {
    super.attach(observer);
    observer.orientationListener(this.state);
  }
  isEqual(newState) {
    return newState.landscape === this.state.landscape && newState.portrait === this.state.portrait;
  }
}
const balOrientationSubject = new BalOrientationSubject();

class BalModalController {
  constructor() {
    this.tag = 'bal-modal';
  }
  create(options) {
    if (typeof customElements !== 'undefined' && balBrowser.hasDocument) {
      return customElements.whenDefined(this.tag).then(() => {
        const element = document.createElement(this.tag);
        Object.assign(element, options);
        getAppRoot(document).appendChild(element);
        return new Promise(resolve => componentOnReady(element, resolve));
      });
    }
    return Promise.resolve();
  }
  async dismissAll(data, role) {
    if (balBrowser.hasDocument) {
      const overlays = getOverlays(document, this.tag);
      await Promise.all(overlays.map(o => o.dismiss(data, role)));
    }
  }
  dismiss(data, role, id) {
    if (balBrowser.hasDocument) {
      const overlay = getOverlay(document, this.tag, id);
      if (!overlay) {
        return Promise.reject('overlay does not exist');
      }
      return overlay.dismiss(data, role);
    }
    return Promise.resolve(false);
  }
  async getTop() {
    if (balBrowser.hasDocument) {
      return getOverlay(document, this.tag);
    }
    return;
  }
}
const balModalController = new BalModalController();

const hasTouchSupport = () => balDevice.hasTouchScreen;
const isBrowser = (browser) => {
  if (browser === 'Safari') {
    return balBrowser.isSafari;
  }
  return false;
};
const getPlatforms = (_win) => balBreakpoints.detect();
const isPlatform = (winOrPlatform, platform) => {
  if (typeof winOrPlatform === 'string') {
    platform = winOrPlatform;
  }
  if (platform) {
    return balBreakpoints.detect().includes(platform);
  }
  return false;
};
const NewBalOptionValue = newBalOptionValue;
const NewBalSingleOptionValue = newBalSingleOptionValue;

export { BalModalController, BalSnackbarController, BalToastController, NewBalOptionValue, NewBalSingleOptionValue, balModalController, balOrientationSubject, balSnackbarController, balToastController, getPlatforms, hasTouchSupport, i18nBalFieldLabel, initializeBaloiseDesignSystem, isBrowser, isPlatform, newBalCheckboxOption, newBalOptionValue, newBalRadioOption, newBalSingleOptionValue };
